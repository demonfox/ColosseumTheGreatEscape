<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Colosseum Escape: Roman Architect By Roy</title>
    <style>
        :root {
            --bg: #1a1a1a;
            --stone: #7f8c8d;
            --path-off: #2c3e50;
            --path-on: #e74c3c;
            --gold: #f1c40f;
            --roman-red: #8b0000;
            --gladiator-bg: #4a231e;
            --scroll-bg: #f4e4bc;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0; padding: 20px;
            user-select: none;
            overflow: hidden;
        }

        .hud {
            display: flex; gap: 20px; width: 100%; max-width: 600px;
            justify-content: space-between; align-items: center;
            background: #333; padding: 15px; border-radius: 10px;
            border-bottom: 3px solid var(--gold); margin-bottom: 10px;
        }
        .hud-item { font-size: 1.1rem; font-weight: bold; }
        #timer { color: var(--gold); font-family: monospace; font-size: 1.4rem; }
        .danger { color: #ff4444 !important; animation: pulse 0.5s infinite; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

        #board-container {
            display: flex; justify-content: center; align-items: center;
            flex-grow: 1; margin: 10px 0;
        }
        #board {
            display: grid; gap: 4px; background: #444; padding: 8px;
            border-radius: 8px; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .tile {
            width: 60px; height: 60px; background: var(--stone);
            border-radius: 4px; position: relative; cursor: pointer;
            transition: transform 0.2s;
        }
        .tile.small { width: 45px; height: 45px; } 

        .pipe-center {
            position: absolute; width: 30%; height: 30%; background: var(--path-off);
            left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 2;
        }
        .pipe-arm { position: absolute; background: var(--path-off); transition: 0.3s; }
        .arm-0 { width: 30%; height: 50%; left: 50%; top: 0; transform: translateX(-50%); }
        .arm-1 { width: 50%; height: 30%; right: 0; top: 50%; transform: translateY(-50%); }
        .arm-2 { width: 30%; height: 50%; left: 50%; bottom: 0; transform: translateX(-50%); }
        .arm-3 { width: 50%; height: 30%; left: 0; top: 50%; transform: translateY(-50%); }

        .tile.active .pipe-center, .tile.active .pipe-arm {
            background: var(--path-on); box-shadow: 0 0 10px var(--path-on);
        }

        .tile.locked { border: 2px solid var(--gold); box-sizing: border-box; }
        .tile.gladiator { background: var(--gladiator-bg); cursor: not-allowed; border: 2px solid #e74c3c; }
        .icon { position: absolute; font-size: 24px; z-index: 10; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; }

        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.92); z-index: 200;
            display: none; justify-content: center; align-items: center;
            flex-direction: column; text-align: center;
        }
        .modal {
            background: var(--scroll-bg); color: #2b1d0e; padding: 30px;
            max-width: 500px; border-radius: 8px; border: 8px double var(--roman-red);
            box-shadow: 0 0 60px rgba(0,0,0,0.9);
        }
        .modal h2 { color: var(--roman-red); border-bottom: 2px solid #8d6e63; padding-bottom: 10px; margin-top: 0;}
        .modal p { font-size: 1rem; line-height: 1.5; text-align: left; }
        .modal ul { text-align: left; padding-left: 20px; }
        .modal li { margin-bottom: 10px; font-weight: bold; }
        
        .big-btn {
            background: var(--roman-red); color: white; border: none; padding: 12px 35px;
            font-size: 1.1rem; font-weight: bold; border-radius: 50px;
            cursor: pointer; margin-top: 15px;
        }
        .secondary-btn {
            background: transparent; border: 2px solid var(--roman-red); color: var(--roman-red);
            margin-top: 10px; padding: 8px 25px; border-radius: 50px; cursor: pointer; font-weight: bold;
        }
    </style>
</head>
<body>

    <div class="hud">
        <div class="hud-item">üèüÔ∏è Sector: <span id="level-name">Loading...</span></div>
        <div class="hud-item">‚è≥ Time: <span id="timer">60</span>s</div>
    </div>

    <div id="board-container">
        <div id="board"></div>
    </div>

    <div id="modal-story" class="overlay" style="display: flex;">
        <div class="modal">
            <h2>üìú The Roman Mission</h2>
            <p>The year is <b>AD 80</b>. You are the head builder for the Roman Emperor.</p>
            <p>50,000 Roman citizens are inside the <b>Colosseum</b>. The show is over, and everyone wants to go home!</p>
            <p>The hallways (called <b>Vomitoria</b>) are all mixed up. If you don't fix them fast, the crowd will get angry!</p>
            <button class="big-btn" onclick="showRules()">Next: How to Play</button>
        </div>
    </div>

    <div id="modal-rules" class="overlay">
        <div class="modal">
            <h2>üìã How to Play</h2>
            <p>Be fast! The Emperor is watching!</p>
            <ul>
                <li><b>Click a Tile:</b> Rotate it to fix the path.</li>
                <li><b>Make it Glow:</b> Connect Seats (üèüÔ∏è) to the Gate (üö™).</li>
                <li><b>Avoid Gladiators (‚öîÔ∏è):</b> They are fighting! You must go around them.</li>
                <li><b>Gain Time:</b> Clear levels 1, 2, and 3 to get <b>+30 seconds</b>.</li>
            </ul>
            <button class="big-btn" onclick="startGame()">Start Game!</button>
            <br>
            <button class="secondary-btn" onclick="backToStory()">Go Back</button>
        </div>
    </div>

    <div id="modal-next" class="overlay">
        <div class="modal">
            <h2>üéâ Level Clear!</h2>
            <p style="text-align: center;">The crowd is safe. Keep going!</p>
            <p style="text-align: center; color: green; font-weight: bold; font-size: 1.2em;">+30 Seconds Bonus</p>
            <button class="big-btn" onclick="nextLevel()">Next Level</button>
        </div>
    </div>

    <div id="modal-fail" class="overlay">
        <div class="modal">
            <h2>üíÄ Too Late!</h2>
            <p style="text-align: center;">The crowd got stuck. Rome is in chaos!</p>
            <button class="big-btn" onclick="location.reload()">Try Again</button>
        </div>
    </div>

    <div id="modal-win" class="overlay">
        <div class="modal">
            <h2>üèÜ Ultimate Victory!</h2>
            <p style="text-align: center;">You have conquered <b>HELL MODE</b>!</p>
            <p style="text-align: center;">You saved all 50,000 Roman citizens. You are a hero of Rome!</p>
            <p style="text-align: center; font-size: 1.2em; border-top: 1px solid #ccc; padding-top: 10px;">
                Final Time Left: <span id="final-time" style="color: #d35400; font-weight: bold;"></span>s
            </p>
            <div style="font-size: 3rem; margin: 10px;">üëç</div>
            <button class="big-btn" onclick="location.reload()">Play Again</button>
        </div>
    </div>

    <script>
        const LEVELS = [
            { name: "1. Easy", size: 3, glads: 0 },
            { name: "2. Normal", size: 4, glads: 0 },
            { name: "3. Hard", size: 6, glads: 3 },
            { name: "4. HELL MODE", size: 8, glads: 5 }
        ];

        let currentLevelIdx = 0;
        let timeLeft = 60;
        let timerInterval = null;
        let grid = [];
        let isPaused = true;
        const UP=0, RIGHT=1, DOWN=2, LEFT=3;

        function showRules() {
            document.getElementById('modal-story').style.display = 'none';
            document.getElementById('modal-rules').style.display = 'flex';
        }
        function backToStory() {
            document.getElementById('modal-rules').style.display = 'none';
            document.getElementById('modal-story').style.display = 'flex';
        }
        function startGame() {
            document.getElementById('modal-rules').style.display = 'none';
            currentLevelIdx = 0; timeLeft = 60;
            startLevel(); startTimer();
        }
        function startLevel() {
            isPaused = false;
            const config = LEVELS[currentLevelIdx];
            document.getElementById('level-name').innerText = config.name;
            const boardEl = document.getElementById('board');
            boardEl.style.gridTemplateColumns = `repeat(${config.size}, ${config.size > 6 ? 45 : 60}px)`;
            generateLevel(config); render(config); checkConnectivity();
        }
        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if(!isPaused) { timeLeft--; updateTimerUI(); if(timeLeft <= 0) gameOver(); }
            }, 1000);
        }
        function updateTimerUI() {
            const el = document.getElementById('timer');
            el.innerText = timeLeft;
            if(timeLeft <= 10) el.classList.add('danger'); else el.classList.remove('danger');
        }

        // --- WIN LOGIC ---
        function handleWin() {
            isPaused = true;
            // Check if this was the last level (HELL MODE)
            if (currentLevelIdx === LEVELS.length - 1) {
                // Skip next-level pop-up, skip extra time, go to final victory
                clearInterval(timerInterval);
                document.getElementById('final-time').innerText = timeLeft;
                document.getElementById('modal-win').style.display = 'flex';
            } else {
                // Not the last level: add time and show intermediate pop-up
                timeLeft += 30;
                updateTimerUI();
                document.getElementById('modal-next').style.display = 'flex';
            }
        }

        function nextLevel() {
            document.getElementById('modal-next').style.display = 'none';
            currentLevelIdx++;
            startLevel();
        }

        function gameOver() { 
            isPaused = true; 
            clearInterval(timerInterval); 
            document.getElementById('modal-fail').style.display = 'flex'; 
        }
        
        // --- Map Generation ---
        function generateLevel(config) {
            grid = []; const size = config.size;
            for(let y=0; y<size; y++) for(let x=0; x<size; x++) grid.push({ x, y, rotation: 0, arms: [], type: 'normal', active: false, el: null });
            getTile(0,0, size).type = 'start'; getTile(0,0, size).arms = [UP];
            getTile(size-1, size-1, size).type = 'end'; getTile(size-1, size-1, size).arms = [DOWN];
            let gladsPlaced = 0;
            while(gladsPlaced < config.glads) {
                let rx = Math.floor(Math.random()*size); let ry = Math.floor(Math.random()*size);
                let t = getTile(rx, ry, size); if(t.type === 'normal') { t.type = 'gladiator'; gladsPlaced++; }
            }
            if (!createPath(size)) { generateLevel(config); return; }
            grid.forEach(t => {
                if(t.type === 'normal' && t.arms.length === 0) t.arms = Math.random() > 0.5 ? [0, 2] : [0, 1];
                if(t.type === 'normal') t.rotation = Math.floor(Math.random() * 4);
            });
        }
        function createPath(size) {
            let curr = {x:0, y:0}; let path = [curr]; let visited = new Set(['0,0']); let steps = 400;
            while((curr.x !== size-1 || curr.y !== size-1) && steps > 0) {
                steps--; let moves = [];
                [{dx:1,dy:0},{dx:0,dy:1},{dx:-1,dy:0},{dx:0,dy:-1}].forEach(m => {
                    let nx = curr.x+m.dx, ny = curr.y+m.dy;
                    if(nx>=0 && nx<size && ny>=0 && ny<size && !visited.has(`${nx},${ny}`) && getTile(nx,ny,size).type !== 'gladiator') moves.push({x:nx,y:ny});
                });
                if(moves.length === 0) return false;
                curr = moves[Math.floor(Math.random()*moves.length)]; path.push(curr); visited.add(`${curr.x},${curr.y}`);
            }
            if(curr.x !== size-1 || curr.y !== size-1) return false;
            for(let i=0; i<path.length; i++) {
                let t = getTile(path[i].x, path[i].y, size); let arms = [];
                if(i > 0) arms.push(getRelativeDir(path[i], path[i-1])); else arms.push(UP);
                if(i < path.length-1) arms.push(getRelativeDir(path[i], path[i+1])); else arms.push(DOWN);
                t.arms = arms;
            }
            return true;
        }
        function getTile(x, y, size) { return grid[y*size + x]; }
        function getRelativeDir(f, t) { if(t.y<f.y) return UP; if(t.x>f.x) return RIGHT; if(t.y>f.y) return DOWN; return LEFT; }
        
        function render(config) {
            const b = document.getElementById('board'); b.innerHTML = '';
            grid.forEach(t => {
                let el = document.createElement('div'); el.className = 'tile' + (config.size>6?' small':'');
                if(t.type === 'gladiator') { el.classList.add('gladiator'); el.innerHTML = '<div class="icon">‚öîÔ∏è</div>'; }
                else {
                    if(t.type==='start') el.innerHTML = '<div class="icon">üèüÔ∏è</div>'; else if(t.type==='end') el.innerHTML = '<div class="icon">üö™</div>';
                    el.innerHTML += '<div class="pipe-center"></div>';
                    t.arms.forEach(d => el.innerHTML += `<div class="pipe-arm arm-${d}"></div>`);
                    if(t.type !== 'start' && t.type !== 'end') el.onclick = () => { if(!isPaused) { t.rotation = (t.rotation+1)%4; el.style.transform = `rotate(${t.rotation*90}deg)`; checkConnectivity(config.size); } };
                }
                el.style.transform = `rotate(${t.rotation*90}deg)`; t.el = el; b.appendChild(el);
            });
        }
        function checkConnectivity(size) {
            grid.forEach(t => { t.active = false; if(t.el) t.el.classList.remove('active'); });
            let q = [grid[0]]; grid[0].active = true; grid[0].el.classList.add('active');
            let won = false;
            while(q.length > 0) {
                let c = q.shift(); if(c.type === 'end') won = true;
                let cA = c.arms.map(a => (a+c.rotation)%4);
                [{dx:0,dy:-1,d:UP,o:DOWN},{dx:1,dy:0,d:RIGHT,o:LEFT},{dx:0,dy:1,d:DOWN,o:UP},{dx:-1,dy:0,d:LEFT,o:RIGHT}].forEach(n => {
                    let nx = c.x+n.dx, ny = c.y+n.dy;
                    if(nx>=0 && nx<size && ny>=0 && ny<size) {
                        let nt = getTile(nx,ny,size);
                        if(nt.type !== 'gladiator' && !nt.active && cA.includes(n.d) && nt.arms.map(a=>(a+nt.rotation)%4).includes(n.o)) { nt.active=true; nt.el.classList.add('active'); q.push(nt); }
                    }
                });
            }
            if(won) setTimeout(handleWin, 300);
        }
    </script>
</body>
</html>